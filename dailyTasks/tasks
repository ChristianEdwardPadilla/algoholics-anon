
Heap with 4 methods:
(a heap is typcially implemented as a normal array)
  -push: add element to the heap and re-heapify
  -delMin (or delMax for maxHeap): remove (and return) the root element and re-heapify
  -sink: re-heapify element at given index downwards. Compares the element with its children, 
         swapping if either is smaller (chooses smaller if both are).
         Continues to swap until candidate element is smaller than both children.
  -swim: re-heapify element at given index upwards. Compares the element with its parent,
         swapping if parent is bigger. Continues to swap until parent is smaller.

BST with 4 methods:
  -add: add element with given value to the BST
  -contains: returns true if BST contains given element, false otherwise
  -max: return max element in BST
  -min: returns min element in BST

Inerstion sort:
  -assemble a sorted set as a pointer makes a single scan across the array

Merge sort:
  -log(n) divisions, n merges
  -make a version that transitions to insertion sort when the array length is <= 20

Quick sort:
  -partioning an array with resepect to some value is a linear process (like merging a sorted array)

Quick select:
  -partition or something

Binary search:
  -do both iterative and recursive 
  (in interview, use iterative if the point is to implement the search, use recursive if it's just a tool, 
  then mention that iterative doesn't have the stack frame disadvantage)




Hash map with 4 methods:
  -set: adds element to a bucket, deals with potential collisions somehow
  -get: returns value of associated key, undefined if not found
  -remove: removes entry for given key
  -resize: if adding an element puts the total number of elements above 25% the size of the map, double the size of the map and re-hash the boys
  -use following hash function:

function hashFunc(string, size) {
  let hash = 0;
  if (string.length === 0) return hash;

  for (let i = 0; i < string.length; i += 1) {
    const letter = string.charCodeAt(i);
    hash = (hash << 5) - hash + letter;
    hash &= hash; // Convert to 32bit integer
  }

  return Math.abs(hash) % size;
}
